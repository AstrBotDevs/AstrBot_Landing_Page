name: Sync from upstream

on:
  schedule:
    - cron: '0 3 * * *' # 每天 03:00 UTC 同步（可修改）
  workflow_dispatch:
    inputs:
      upstream_repo:
        description: 'Upstream repository in owner/repo format (e.g. upstream-owner/upstream-repo). If empty, will use secrets.UPSTREAM_REPO.'
        required: false
      upstream_branch:
        description: 'Branch name on upstream to sync from.'
        required: false
        default: 'master'   
      target_branch:
        description: 'Branch name in this repo to update.'
        required: false
        default: 'master'   

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      UPSTREAM_REPO: ${{ github.event.inputs.upstream_repo || secrets.UPSTREAM_REPO || '' }}
      UPSTREAM_BRANCH: ${{ github.event.inputs.upstream_branch || 'master' }}
      TARGET_BRANCH: ${{ github.event.inputs.target_branch || 'master' }}
    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Debug info before sync
        run: |
          echo "UPSTREAM_REPO=${UPSTREAM_REPO}"
          echo "UPSTREAM_BRANCH=${UPSTREAM_BRANCH}"
          echo "TARGET_BRANCH=${TARGET_BRANCH}"
          git remote -v || true
          git branch -a || true
          git rev-parse --verify HEAD || true
          git ls-remote origin refs/heads/${TARGET_BRANCH} || true

      - name: Add upstream remote and fetch upstream branch
        run: |
          if [ -z "${UPSTREAM_REPO}" ]; then
            echo "Error: UPSTREAM_REPO not set. Provide via workflow_dispatch input or secrets.UPSTREAM_REPO."
            exit 1
          fi
          git remote add upstream "https://github.com/${UPSTREAM_REPO}" || true
          # fetch the specific upstream branch so we have upstream/${UPSTREAM_BRANCH}
          git fetch upstream ${UPSTREAM_BRANCH} --depth=1

      - name: Ensure local target branch exists and checkout
        run: |
          # 如果本地不存在 TARGET_BRANCH，从 origin 拉下来并建立本地分支
          if git show-ref --verify --quiet refs/heads/${TARGET_BRANCH}; then
            echo "Local branch ${TARGET_BRANCH} exists"
          else
            # 如果 origin 上有该分支，拉下来；否则创建空分支
            if git ls-remote --heads origin ${TARGET_BRANCH} | grep ${TARGET_BRANCH}; then
              git fetch origin ${TARGET_BRANCH}:${TARGET_BRANCH} || true
            else
              git checkout --orphan ${TARGET_BRANCH} || git checkout -b ${TARGET_BRANCH}
              # 清空工作树以避免奇怪状态
              git reset --hard
            fi
          fi
          git checkout ${TARGET_BRANCH}

      - name: Show diff upstream vs origin (for info)
        run: |
          echo "Commits upstream not in origin:"
          git fetch upstream ${UPSTREAM_BRANCH}
          git log --oneline origin/${TARGET_BRANCH}..upstream/${UPSTREAM_BRANCH} || echo "(no commits or origin branch missing)"
          echo "Files changed (upstream vs origin):"
          git diff --name-status origin/${TARGET_BRANCH}..upstream/${UPSTREAM_BRANCH} || echo "(no diff or origin branch missing)"

      - name: Merge upstream into target (handle unrelated histories & fallback to reset)
        id: merge_step
        run: |
          set -e
          NEED_FORCE=false
          git fetch upstream ${UPSTREAM_BRANCH}
          # 尝试快进
          if git merge --ff-only upstream/${UPSTREAM_BRANCH}; then
            echo "Fast-forwarded from upstream/${UPSTREAM_BRANCH}"
          else
            echo "Fast-forward failed, trying merge with --allow-unrelated-histories"
            if git merge --no-edit --allow-unrelated-histories upstream/${UPSTREAM_BRANCH}; then
              echo "Merged with allow-unrelated-histories"
            else
              echo "Merge still failed, backing up current branch and resetting to upstream (will require force push)"
              BACKUP=backup-before-sync-$(date +%Y%m%d%H%M%S)
              git branch ${BACKUP} || true
              echo "Created backup branch ${BACKUP}"
              git reset --hard upstream/${UPSTREAM_BRANCH}
              echo "Reset local ${TARGET_BRANCH} to upstream/${UPSTREAM_BRANCH}"
              NEED_FORCE=true
            fi
          fi
          echo "NEED_FORCE=${NEED_FORCE}" > merge_step_env

      - name: Read merge result
        run: |
          cat merge_step_env || true

      - name: Push to origin (ensure using PAT; unset extraheader)
        env:
          PAT: ${{ secrets.PAT }}
        run: |
          set -ex
          # 读取 NEED_FORCE
          NEED_FORCE=$(cut -d'=' -f2 merge_step_env || echo "false")
          echo "NEED_FORCE=${NEED_FORCE}"
      
          # debug: show extraheader if present (masked in logs)
          echo "http.https://github.com/.extraheader (before):"
          git config --local --get-all http.https://github.com/.extraheader || echo "(none)"
      
          if [ -z "${PAT}" ]; then
            echo "PAT secret is empty — aborting to avoid using GITHUB_TOKEN silently"
            exit 1
          fi
      
          # Unset the extraheader that actions/checkout may have set (prevents always using GITHUB_TOKEN)
          git config --local --unset-all http.https://github.com/.extraheader || true
          # verify cleared
          echo "http.https://github.com/.extraheader (after):"
          git config --local --get-all http.https://github.com/.extraheader || echo "(cleared)"
      
          # Make origin point to URL that embeds PAT (this avoids using previously-cached credentials)
          git remote set-url origin "https://x-access-token:${PAT}@github.com/${{ github.repository }}"
      
          # Try safe push first
          if [ "${NEED_FORCE}" = "true" ]; then
            echo "Need to force update remote; trying safe force-with-lease first"
            git push origin ${TARGET_BRANCH} --force-with-lease || \
            (echo "force-with-lease failed, trying plain --force" && git push origin ${TARGET_BRANCH} --force)
          else
            git push origin ${TARGET_BRANCH} || git push origin ${TARGET_BRANCH} --force-with-lease
          fi

      - name: Final debug (show new remote HEAD)
        run: |
          echo "Origin HEAD after push:"
          git ls-remote origin refs/heads/${TARGET_BRANCH} || true
